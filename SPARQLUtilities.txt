PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX drmo: <http://www.semanticweb.org/ontologies/2022/titutuli/nivedita/drmo#>
PREFIX obo: <http://purl.obolibrary.org/obo/>
PREFIX dct: <http://purl.org/dc/terms/>
PREFIX bib: <http://purl.org/ontology/bibo/uri>
PREFIX mesh: <http://purl.bioontology.org/ontology/MESH/>

# Adding some queries to just display data
# Documents with sub-sections and text
SELECT *
WHERE {?document drmo:hasSubSection ?section.
       ?section drmo:text ?text.}

# Documents and authors need labels because IRIs are usually UUIDs	   
SELECT ?doclabel ?authorlabel
WHERE {?document drmo:hasAuthor ?author;
                 rdfs:label ?doclabel.
	    ?author rdfs:label ?authorlabel.} ORDER BY ?doclabel

# Documents that have isAbout links to domain entities
# Love those highly intuitive OBO IRIs ;-)
SELECT *
WHERE {?document obo:IAO_0000136 ?entity.}

# All documents and most relevant info
SELECT *
WHERE {?document a drmo:Document.
OPTIONAL{?document drmo:hasSubSection ?section.
       ?section drmo:text ?text.}
OPTIONAL {?document drmo:hasAuthor ?author.}
OPTIONAL {?document obo:IAO_0000136 ?entity.}}

# The next 6 are to do strings to things after loading new documents 
# 1. View titles for docs with no labels
SELECT *
WHERE {?doc a drmo:Document;
        dct:title ?title.
	   OPTIONAL{?doc rdfs:label ?elbl.}
       FILTER(?doc != owl:Thing && ?doc != owl:Nothing && !BOUND(?elbl) &&  ?title != "")}
	   
# 2. Construct labels for documents with no label using title	   
CONSTRUCT {?doc rdfs:label ?title}
WHERE {?doc a drmo:Document;
        dct:title ?title.
	   OPTIONAL{?doc rdfs:label ?elbl.}
       FILTER(?doc != owl:Thing && ?doc != owl:Nothing && !BOUND(?elbl) &&  ?title != "")}
	   
# 3. Find documents whose source string matches the label of a publisher object and who don't have a publishedIn value	   
SELECT *
WHERE {?doc dct:source ?slabel.
       ?pub rdfs:label ?slabel.
	   OPTIONAL{?doc drmo:publishedIn ?epub.}
	   FILTER(!BOUND(?epub))}
	   
# 4. List journals that should but don't exist yet   
SELECT *
WHERE {?doc dct:source ?slabel.
	   OPTIONAL{?doc drmo:publishedIn ?epub.}
	   OPTIONAL{?esource rdfs:label ?slabel.}
	   FILTER(!BOUND(?epub) && !BOUND(?esource))}
	   
# 5. Create journals that should but don't exist yet   
CONSTRUCT {?niri a drmo:Journal;
                 rdfs:label ?slabel.}
WHERE {?doc dct:source ?slabel.
       BIND (IRI(CONCAT(STR(drmo:), STRUUID())) AS ?niri)
	   OPTIONAL{?doc drmo:publishedIn ?epub.}
	   OPTIONAL{?esource rdfs:label ?slabel.}
	   FILTER(!BOUND(?epub) && !BOUND(?esource))}
	   
# 6. Create publishedIn values for documents whose source string matches the label of a publisher object
# and that don't currently have a value for publishedIn	   
CONSTRUCT {?doc drmo:publishedIn ?pub}
WHERE {?doc dct:source ?slabel.
       ?pub rdfs:label ?slabel.
	   OPTIONAL{?doc drmo:publishedIn ?epub.}
	   FILTER(!BOUND(?epub))}

# Check for duplicate entities
SELECT *
WHERE {?s1 rdfs:label ?label.
       ?s2 rdfs:label ?label.
FILTER(STR(?s1) < STR(?s2))}

# Delete duplicate entities
DELETE {?s2 ?p ?o.}
WHERE {?s1 rdfs:label ?label.
       ?s2 rdfs:label ?label;
	        ?p ?o.
FILTER(STR(?s1) < STR(?s2))}
	   
# The following are to generate labels from the IRIs of objects with intuitive names. 
# Run this after creating lots of new entities. It generates labels so you don't have to do it manually.
# Uses CONSTRUCT so that it can run in Snap SPARQL in Protege. If running in AllegroGraph change
# CONSTRUCT to INSERT. Also, doesn't handle acronyms correctly. e.g. a class like CDCEmployee
# would get the label: "C D C Employee" I just change those by hand. 

#Create labels from IRIs for all Individuals with no label		
CONSTRUCT {?i rdfs:label ?lblname.}
WHERE {?i a owl:Thing.
    BIND(STRAFTER(STR(?i), '#') as ?name)
	BIND(REPLACE(?name,"([A-Z])", " $1" ) as ?namewbs)
	BIND (IF (STRSTARTS(?namewbs," "),SUBSTR(?namewbs,1),?namewbs) AS ?lblname)
	OPTIONAL{?i rdfs:label ?elbl.}
	FILTER(!BOUND(?elbl) &&  ?lblname != "")}

#Create labels for all Classes
CONSTRUCT {?c rdfs:label ?lblname.}
WHERE {?c rdfs:subClassOf owl:Thing.
    BIND(STRAFTER(STR(?c), '#') as ?name)
	BIND(REPLACE(?name,"([A-Z])", " $1" ) as ?namewbs)
	BIND (IF (STRSTARTS(?namewbs," "),SUBSTR(?namewbs,1),?namewbs) AS ?lblname)
	OPTIONAL{?c rdfs:label ?elbl.}
	FILTER(?c != owl:Thing && ?c != owl:Nothing && !BOUND(?elbl) && ?lblname != "")}		

#Create labels for all Object Properties
CONSTRUCT {?p rdfs:label ?lblname.}
WHERE {?p a owl:ObjectProperty.
    BIND(STRAFTER(STR(?p), '#') as ?name)
	BIND(REPLACE(?name,"([A-Z])", " $1" ) as ?lblname)
	OPTIONAL{?p rdfs:label ?elbl.}
	FILTER(?p != owl:topObjectProperty && !BOUND(?elbl) &&  ?lblname != "")}	

#Create labels for all Data Properties
CONSTRUCT {?p rdfs:label ?lblname.}
WHERE {?p a owl:DatatypeProperty.
    BIND(STRAFTER(STR(?p), '#') as ?name)
	BIND(REPLACE(?name,"([A-Z])", " $1" ) as ?lblname)		
	OPTIONAL{?p rdfs:label ?elbl.}
	FILTER(?p != owl:topDataProperty && !BOUND(?elbl) &&  ?lblname != "")}	
	
# List all the instances and their property values this will be a lot of triples
# So best to use with some limit
SELECT *
WHERE {?i rdf:type owl:NamedIndividual;
          ?p ?o.
		?s ?p1 ?i.} LIMIT 1000
		
# DELETE all the instances and their property values
# Can use query above to make sure this works
DELETE {?i ?p ?o.
         ?s ?p1 ?i.}
WHERE {?i rdf:type owl:NamedIndividual;
          ?p ?o.
		?s ?p1 ?i.} 